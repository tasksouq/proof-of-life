// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {ERC721Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import {ERC721URIStorageUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol";
import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
contract Property is Initializable, ERC721Upgradeable, ERC721URIStorageUpgradeable, UUPSUpgradeable, OwnableUpgradeable {
    uint256 private _tokenIdCounter;
    
    // Property metadata structure
    struct PropertyMetadata {
        string name;
        string propertyType; // e.g., "house", "apartment", "office", "land"
        string location; // e.g., "New York", "Tokyo", "London"
        uint256 level; // Property level (1-10)
        uint256 statusPoints; // Status points generated by this property
        uint256 yieldRate; // Yield rate in basis points (e.g., 500 = 5%)
        uint256 purchasePrice; // Original purchase price in LIFE tokens
        uint256 createdAt; // Timestamp when property was created
        uint256 lastTransferTime;
        address originalOwner;
    }
    
    // Mapping from token ID to property metadata
    mapping(uint256 => PropertyMetadata) public properties;
    
    // Mapping from property type to base status points
    mapping(string => uint256) public baseStatusPoints;
    
    // Mapping from property type to base yield rate
    mapping(string => uint256) public baseYieldRates;
    
    // Authorized minters (Economy contract, etc.)
    mapping(address => bool) public authorizedMinters;
    
    // Events
    event PropertyMinted(uint256 indexed tokenId, address indexed owner, string name, string propertyType, string location, uint256 level);
    event PropertyUpgraded(uint256 indexed tokenId, uint256 newLevel, uint256 newStatusPoints, uint256 newYieldRate);
    event AuthorizedMinterAdded(address indexed minter);
    event AuthorizedMinterRemoved(address indexed minter);
    event BaseStatsUpdated(string propertyType, uint256 statusPoints, uint256 yieldRate);
    
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }
    
    function initialize(address _owner) public initializer {
        __ERC721_init("LIFE Property", "LPROP");
        __ERC721URIStorage_init();
        __UUPSUpgradeable_init();
        __Ownable_init(_owner);
        
        // Initialize base status points and yield rates for different property types
        baseStatusPoints["house"] = 100;
        baseStatusPoints["apartment"] = 50;
        baseStatusPoints["office"] = 200;
        baseStatusPoints["land"] = 75;
        baseStatusPoints["mansion"] = 500;
        
        baseYieldRates["house"] = 300; // 3%
        baseYieldRates["apartment"] = 200; // 2%
        baseYieldRates["office"] = 500; // 5%
        baseYieldRates["land"] = 100; // 1%
        baseYieldRates["mansion"] = 800; // 8%
    }
    
    function mintProperty(
        address to,
        string memory name,
        string memory propertyType,
        string memory location,
        uint256 level,
        uint256 purchasePrice,
        string memory _tokenURI
    ) external returns (uint256) {
        require(authorizedMinters[msg.sender], "Not authorized to mint");
        require(level >= 1 && level <= 10, "Level must be between 1 and 10");
        require(bytes(name).length > 0, "Name cannot be empty");
        require(bytes(propertyType).length > 0, "Property type cannot be empty");
        require(bytes(location).length > 0, "Location cannot be empty");
        require(baseStatusPoints[propertyType] > 0, "Invalid property type");
        
        uint256 tokenId = _tokenIdCounter;
        _tokenIdCounter++;
        
        // Calculate status points and yield rate based on type and level
        uint256 statusPoints = baseStatusPoints[propertyType] * level;
        uint256 yieldRate = baseYieldRates[propertyType] + (level - 1) * 50; // +0.5% per level
        
        // Store property metadata
        properties[tokenId] = PropertyMetadata({
            name: name,
            propertyType: propertyType,
            location: location,
            level: level,
            statusPoints: statusPoints,
            yieldRate: yieldRate,
            purchasePrice: purchasePrice,
            createdAt: block.timestamp,
            lastTransferTime: block.timestamp,
            originalOwner: to
        });
        
        _mint(to, tokenId);
        _setTokenURI(tokenId, _tokenURI);
        
        emit PropertyMinted(tokenId, to, name, propertyType, location, level);
        
        return tokenId;
    }
    
    function upgradeProperty(uint256 tokenId) external {
        require(_ownerOf(tokenId) != address(0), "Property does not exist");
        require(ownerOf(tokenId) == msg.sender, "Not the owner of this property");
        
        PropertyMetadata storage property = properties[tokenId];
        require(property.level < 10, "Property already at maximum level");
        
        property.level++;
        property.statusPoints = baseStatusPoints[property.propertyType] * property.level;
        property.yieldRate = baseYieldRates[property.propertyType] + (property.level - 1) * 50;
        
        emit PropertyUpgraded(tokenId, property.level, property.statusPoints, property.yieldRate);
    }
    
    function getProperty(uint256 tokenId) external view returns (
        string memory name,
        string memory propertyType,
        string memory location,
        uint256 level,
        uint256 statusPoints,
        uint256 yieldRate,
        uint256 purchasePrice,
        uint256 createdAt
    ) {
        require(_ownerOf(tokenId) != address(0), "Property does not exist");
        PropertyMetadata memory prop = properties[tokenId];
        return (
            prop.name,
            prop.propertyType,
            prop.location,
            prop.level,
            prop.statusPoints,
            prop.yieldRate,
            prop.purchasePrice,
            prop.createdAt
        );
    }
    
    // Function to get property with ownership tracking
    function getPropertyWithOwnership(uint256 tokenId) external view returns (
        string memory name,
        string memory propertyType,
        string memory location,
        uint256 level,
        uint256 statusPoints,
        uint256 yieldRate,
        uint256 purchasePrice,
        uint256 createdAt,
        uint256 lastTransferTime,
        address originalOwner,
        uint256 ownershipDuration
    ) {
        require(_ownerOf(tokenId) != address(0), "Property does not exist");
        PropertyMetadata memory prop = properties[tokenId];
        return (
            prop.name,
            prop.propertyType,
            prop.location,
            prop.level,
            prop.statusPoints,
            prop.yieldRate,
            prop.purchasePrice,
            prop.createdAt,
            prop.lastTransferTime,
            prop.originalOwner,
            block.timestamp - prop.lastTransferTime
        );
    }
    
    function getPropertiesByOwner(address owner) external view returns (uint256[] memory) {
        uint256 balance = balanceOf(owner);
        uint256[] memory tokenIds = new uint256[](balance);
        uint256 currentIndex = 0;
        
        for (uint256 i = 0; i < _tokenIdCounter; i++) {
            if (_ownerOf(i) != address(0) && ownerOf(i) == owner) {
                tokenIds[currentIndex] = i;
                currentIndex++;
            }
        }
        
        return tokenIds;
    }
    
    function getTotalStatusPoints(address owner) external view returns (uint256) {
        uint256 totalPoints = 0;
        uint256 balance = balanceOf(owner);
        
        for (uint256 i = 0; i < _tokenIdCounter; i++) {
            if (_ownerOf(i) != address(0) && ownerOf(i) == owner) {
                totalPoints += properties[i].statusPoints;
            }
        }
        
        return totalPoints;
    }
    
    function addAuthorizedMinter(address minter) external onlyOwner {
        authorizedMinters[minter] = true;
        emit AuthorizedMinterAdded(minter);
    }
    
    function removeAuthorizedMinter(address minter) external onlyOwner {
        authorizedMinters[minter] = false;
        emit AuthorizedMinterRemoved(minter);
    }
    
    function setAuthorizedMinter(address minter, bool authorized) external onlyOwner {
        authorizedMinters[minter] = authorized;
        if (authorized) {
            emit AuthorizedMinterAdded(minter);
        } else {
            emit AuthorizedMinterRemoved(minter);
        }
    }
    
    function updateBaseStats(string memory propertyType, uint256 statusPoints, uint256 yieldRate) external onlyOwner {
        baseStatusPoints[propertyType] = statusPoints;
        baseYieldRates[propertyType] = yieldRate;
        emit BaseStatsUpdated(propertyType, statusPoints, yieldRate);
    }
    
    function totalSupply() external view returns (uint256) {
        return _tokenIdCounter;
    }
    
    // Required overrides
    function tokenURI(uint256 tokenId) public view override(ERC721Upgradeable, ERC721URIStorageUpgradeable) returns (string memory) {
        return super.tokenURI(tokenId);
    }
    
    function supportsInterface(bytes4 interfaceId) public view override(ERC721Upgradeable, ERC721URIStorageUpgradeable) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
    

    
    // Required by UUPSUpgradeable
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}
    
    // Burn function for property buyback
    function burn(uint256 tokenId) external {
        require(authorizedMinters[msg.sender], "Not authorized to burn");
        require(_ownerOf(tokenId) != address(0), "Property does not exist");
        
        // Clear property metadata
        delete properties[tokenId];
        
        // Burn the NFT
        _burn(tokenId);
    }
    
    // Override transfer functions to track ownership changes
    // Override transfer function to update ownership tracking
    function _update(address to, uint256 tokenId, address auth) internal override returns (address) {
        address from = _ownerOf(tokenId);
        address previousOwner = super._update(to, tokenId, auth);
        
        // Update last transfer time when property changes hands (excluding minting)
        if (from != address(0) && to != address(0)) {
            properties[tokenId].lastTransferTime = block.timestamp;
        }
        
        return previousOwner;
    }
    
    // Function to get ownership duration
    function getOwnershipDuration(uint256 tokenId) external view returns (uint256) {
        require(_ownerOf(tokenId) != address(0), "Property does not exist");
        return block.timestamp - properties[tokenId].lastTransferTime;
    }
    
    // Function to get total property age
    function getPropertyAge(uint256 tokenId) external view returns (uint256) {
        require(_ownerOf(tokenId) != address(0), "Property does not exist");
        return block.timestamp - properties[tokenId].createdAt;
    }
}